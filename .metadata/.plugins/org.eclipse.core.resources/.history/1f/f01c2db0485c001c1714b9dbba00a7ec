package application.view.intermediate;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.List;
import java.util.Date;

import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;

public class RaportGenerator {

	public static List<TimeRaportEntry> generateTimeRaport(List<ScheduleIntermediate> schedules) {

		List<TimeRaportEntry> raport = new ArrayList<TimeRaportEntry>();

		Map<Date, List<ScheduleIntermediate>> groupSchedules = groupByDate(schedules);

		DateFormat formatter = new SimpleDateFormat("dd/MM/yyyy");

		for (Entry<Date, List<ScheduleIntermediate>> entry : groupSchedules.entrySet()) {
			float min = Float.MAX_VALUE;
			float max = Float.MIN_VALUE;
			float sum = 0;
			
			for (ScheduleIntermediate schedule : entry.getValue()) {
				Date arrivalDate = null;

				try {
					arrivalDate = formatter.parse(formatter.format(schedule.getArrival_date()));
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				Date departureDate = null;

				try {
					departureDate = formatter.parse(formatter.format(schedule.getDeparture_date()));
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				float time = departureDate.getTime() - arrivalDate.getTime(); // zwraca czas w milisekundach

				if (min > time) {

					min = time;
				}

				if (max < time) {

					max = time;
				}
				
				sum += time;

			}
		}

		return raport;
	}

	private static Map<Date, List<ScheduleIntermediate>> groupByDate(List<ScheduleIntermediate> schedules) {

		Map<Date, List<ScheduleIntermediate>> raport = new HashMap<Date, List<ScheduleIntermediate>>();

		DateFormat formatter = new SimpleDateFormat("dd/MM/yyyy");

		for (ScheduleIntermediate schedule : schedules) {
			Date scheduledDate = null;

			try {
				scheduledDate = formatter.parse(formatter.format(schedule.getScheduled_date()));
			} catch (ParseException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			if (scheduledDate != null) {
				if (raport.containsKey(scheduledDate)) {
					raport.get(scheduledDate).add(schedule);

				} else {
					List<ScheduleIntermediate> list = new ArrayList<ScheduleIntermediate>();
					list.add(schedule);
					raport.put(scheduledDate, list);
				}
			}
		}

		return raport;

	}

}
